(comment "lib")


(comment "closure")

(global-fun tag-closure)
(assembler (tag-closure v)
  (comment "tag")
  (LSR R0, #3)
  (LSL R0, #3)
  (ORR R0, R0, #3)
  (BX LR))

(global-fun call-closure)
(assembler (call-closure closure args-count arg1 arg2)
  (comment "constructs a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")

  (comment "!!! supporting up to 2 arguments, 1 in closure and 1 passed directly, easy to fix !!!")
  (comment "R0 - closure")
  (comment "R1 - args count")
  (comment "R2 - arg1 optional")
  (comment "R3 - arg2 optional")

  (comment "save arguments")
  (MOV R4, R0)
  (MOV R5, R1)
  (MOV R6, R2)

  (comment "get function address")
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R7, R0)

  (comment "get vector with closure parameters")
  (MOV R0, R4)
  (MOV R1, #1)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R8, R0)

  (comment "get count of closure parameters")
  (BL vector_length)
  (LSR R0, #3)
  (MOV R9, R0)
  (CMP R9, #1)
  (BNE NO_CMP_CLO_PAR)
  (comment "there is one parameter, load")
  (MOV R0, R8)
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R8, R0)

  (NO_CMP_CLO_PAR:)

  (comment "load parameters to registers")

  (LSR R5, #3)
  (CMP R5, #1)
  (BNE NO_NOR_PAR)
  (comment "there is one normal parameter, load")
  (MOV R0, R6)

  (comment "load closure param")
  (CMP R9, #1)
  (BNE NORM_NO_CLO_PAR)
  (comment "there is one closure parameter, load")
  (MOV R1, R8)

  (NORM_NO_CLO_PAR:)
  (B LOAD_PAR_CALL)

  (NO_NOR_PAR:)

  (comment "load closure param")
  (CMP R9, #1)
  (BNE NO_NORM_NO_CLO_PAR)
  (comment "there is one closure parameter, load")
  (MOV R0, R8)

  (NO_NORM_NO_CLO_PAR:)
  (LOAD_PAR_CALL:)
  (MOV LR, PC)
  (ADD LR, LR, #8)
  (MOV PC, R7)

  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(comment "vector")

(global-fun make-vector)
(assembler (make-vector len)
  (comment "constructs a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "allocate memory, (4 + 4 * len) bytes")
  (MOV R4, R0)
  (comment "untag int")
  (LSR R0, #3)
  (ADD R0, R0, #1)
  (MOV R2, #4)
  (MOV R3, R0)
  (MUL R0, R3, R2)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL alloc_mem)
  (comment "set length")
  (STR R4, [R0])
  (comment "tag")
  (ADD R0, R0, #0b101)
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))

(global-fun vector-ref)
(assembler (vector-ref v k)
  (comment "returns element of a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "untag v")
  (AND R3, R0, #0xFFFFFFF8)
  (comment "untag int k")
  (LSR R1, #3)
  (comment "get")
  (MOV R4, #4)
  (ADD R5, R1, #1)
  (MUL R6, R4, R5)
  (ADD R3, R3, R6)
  (LDR R0, [R3])
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(global-fun vector-set!)
(assembler (vector-set! v k obj)
  (comment "sets element of a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "untag v")
  (AND R3, R0, #0xFFFFFFF8)
  (comment "untag int k")
  (LSR R1, #3)
  (comment "set")
  (MOV R4, #4)
  (ADD R5, R1, #1)
  (MUL R6, R4, R5)
  (ADD R3, R3, R6)
  (STR R2, [R3])
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(global-fun vector-length)
(assembler (vector-length v)
  (comment "returns length of a vector")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (LDR R0, [R0])
  (BX LR))


(global-fun vector?)
(assembler (vector? v)
  (comment "checks if x is a vector")
  (comment "vector has a mask 111")
  (comment "vector has a tag 001")
  (AND R0, R0, #0b111)
  (CMP R0, #0b101)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(comment "cons")

(global-fun cons)
(assembler (cons c1 c2)
  (comment "constructs cons")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "allocate memory, 8 bytes")
  (MOV R4, R0)
  (MOV R5, R1)
  (MOV R0, #8)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL alloc_mem)
  (MOV R6, R0)
  (comment "set car")
  (STR R4, [R6])
  (comment "set cdr")
  (ADD R6, R6, #4)
  (STR R5, [R6])
  (comment "tag")
  (ADD R0, R0, #0b001)
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))

(global-fun pair?)
(assembler (pair? a)
  (comment "checks if x is a pair")
  (comment "pair has a mask 111")
  (comment "pair has a tag 001")
  (AND R0, R0, #0b111)
  (CMP R0, #0b001)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))

(global-fun car)
(assembler (car c)
  (comment "returns car of cons")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (LDR R0, [R0])
  (BX LR))

(global-fun cdr)
(assembler (cdr c)
  (comment "returns cdr of cons")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (ADD R0, R0, #4)
  (LDR R0, [R0])
  (BX LR))

(comment "EQUALITY")

(global-fun eq?)
(assembler (eq? a b)
  (comment "equality, compares addresses")
  (comment "implemented incorrectly")
  (CMP R0, R1)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))




(comment "Atom types predicates")

(global-fun atom?)
(assembler (atom? a)
  (comment "checks if x is an atom")
  (comment "number has mask 00001")
  (comment "number has tag 00000")
  (AND R0, R0, #1)
  (CMP R0, #0)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(global-fun number?)
(assembler (number? x)
  (comment "checks if x is a number")
  (comment "number has mask 00111")
  (comment "number has tag 00010")
  (AND R0, R0, #7)
  (CMP R0, #2)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))

(global-fun boolean?)
(assembler (boolean? x)
  (comment "checks if x is boolean")
  (comment "number has mask 00111")
  (comment "number has tag 00100")
  (AND R0, R0, #7)
  (CMP R0, #4)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(comment "Reference types predicates")

(global-fun reference?)
(assembler (reference? a)
  (comment "checks if x is reference")
  (comment "number has mask 00001")
  (comment "number has tag 00001")
  (AND R0, R0, #1)
  (CMP R0, #1)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))
