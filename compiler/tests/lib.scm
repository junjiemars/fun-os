(comment "lib")
(include "common.scm")


(comment "call with current continuation")


(global-fun call-cc)
(assembler (call-cc closure-fun)
  (comment "disable interrupts, REG_IME = 0")
  (LDR R1, REG_IME)
  (LDR R2, [R1])
  (STMFD SP!, {R2})
  (MOV R2, #0)
  (STR R2, [R1])

  (comment "store temporary continuation on the stack")
  (STMFD SP!, {R0})

  (comment "allocate memory for process's state and stack")
  (LDR R0, STACK_SIZE)
  (LDR R1, PROCESS_STATE_SIZE)
  (ADD R0, R0, R1)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL alloc_mem)
  (STMFD SP!, {R0})
  (bl print_int)
  (MOV R0, #26)
  (bl print_int)

  (comment "copy process state")
  (comment "find active proc PCB block")
  (LDR R0, [SL, #8])
  (ADD R1, SL, #8)
  (MOV R2, #0)
  (run_proc_active_pcb_find:)
  (ADD R1, R1, #4)
  (ADD R2, R2, #1)
  (LDR R3, [R1])
  (CMP R0, R3)
  (BEQ run_proc_active_pcb_found)
  (B run_proc_active_pcb_find)

  (run_proc_active_pcb_found:)
  (comment "active pcb found")

  (MOV R3, R2)
  (SUB R2, R2, #1)
  (MOV R0, #84)
  (MUL R1, R2, R0)
  (ADD R2, SL, #412)
  (ADD R1, R1, R2)
  (LDR R0, [SP])

  (comment "save process state")
  (comment "process no")
  (LDR R2, [R1])
  (STR R2, [R0])
  (comment "process priority")
  (LDR R2, [R1, #4])
  (STR R2, [R0, #4])
  (comment "process address")
  (LDR R2, [R1, #8])
  (STR R2, [R0, #8])
  (comment "process state")
  (LDR R2, [R1, #12])
  (STR R2, [R0, #12])
  (comment "process CPSR")
  (MRS R2, CPSR)
  (STR R2, [R1, #16])

  (comment "R0 points to beginning of register part")
  (ADD R0, R0, #20)
  (comment "R0-R3, saved on the stack")
  (comment "R4")
  (STR R4, [R0, #16])
  (comment "R5")
  (STR R5, [R0, #20])
  (comment "R6")
  (STR R6, [R0, #24])
  (comment "R7")
  (STR R7, [R0, #28])
  (comment "R8")
  (STR R8, [R0, #32])
  (comment "R9")
  (STR R9, [R0, #36])
  (comment "R10 - SL")
  (STR R10, [R0, #40])
  (comment "R11 - FP")
  (STR R11, [R0, #44])
  (comment "R12 - IP")
  (STR R12, [R0, #48])
  (comment "R13 - SP")
  (MOV R2, R13)
  (SUB R2, R2, #-8)
  (STR R2, [R0, #52])
  (comment "R14 - LR")
  (STR R14, [R0, #56])
  (comment "R15 - PC - no important, will be overriten")
  (STR R15, [R0, #60])

  (comment "copy process stack")
  (ADD R0, R0, #60)
  (LDR R2, STACK_SIZE)
  (ADD R0, R0, R2)
  (comment "R0 points to beginning of stack save block")
  (LDR R1, STACK_SIZE)
  (SUB R3, R3, #1)
  (MUL R2, R1, R3)
  (LDR R3, [SL])
  (ADD R1, R2, R3)
  (comment "R1 points to beginning of process stack")
  (comment "R3 is a counter")
  (LDR R3, STACK_SIZE)

  (CALL_CC_CPY_STACK:)
  (LDR R2, [R1])
  (STR R2, [R0])
  (SUB R0, R0, #4)
  (ADD R1, R1, #4)

  (CMP R3, #0)
  (SUB R3, R3, #4)
  (BNE CALL_CC_CPY_STACK)

  (comment "create continuation closure")
  (comment "create vector arguments to store process saved state")
  (MOV R0, #1)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL make_vector)
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (LDMFD SP!, {R2})
  (BL vector_setEM)
  (STMFD SP!, {R0})

  (comment "create vector closure continuation")
  (MOV R0, #2)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL make_vector)
  (comment "set function address")
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (ADR R2, cont_closure_callback)
  (BL vector_setEM)
  (comment "set closure arguments")
  (MOV R1, #1)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (LDMFD SP!, {R2})
  (BL vector_setEM)

  (comment "load closure address")
  (LDMFD SP!, {R3})

  (comment "restore interrupts state")
  (LDMFD SP!, {R1})
  (LDR R2, REG_IME)
  (STR R1, [R2])

  (comment "call closure-fun")
  (comment "call-closure var01 1 1")
  (MOV R2, R0)
  (MOV R1, #1)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (MOV R0, R3)
  (BL call_closure)

  (mov r0, #100)
  (bl print_int)

  (comment "function end")
  (BX LR))


(global-fun cont-closure-callback)
(define (cont-closure-callback val cont-address)
  (begin
    (inline "MOV R5, R1")
    (inline "BL print_int")
    (inline "MOV R0, R5")
    (inline "BL print_int")
    (inline "MOV R0, #99")
    (inline "BL print_int")
    3))


(global-fun call-cc2)
(define (call-cc2 closure-fun)
           (closure-fun 3))


(comment "closure")

(global-fun tag-closure)
(assembler (tag-closure v)
  (comment "tag")
  (LSR R0, #3)
  (LSL R0, #3)
  (ORR R0, R0, #3)
  (BX LR))

(global-fun call-closure)
(assembler (call-closure closure args-count arg1 arg2)
  (comment "constructs a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")

  (comment "!!! supporting up to 2 arguments, 1 in closure and 1 passed directly, easy to fix !!!")
  (comment "R0 - closure")
  (comment "R1 - args count")
  (comment "R2 - arg1 optional")
  (comment "R3 - arg2 optional")

  (comment "save arguments")
  (MOV R4, R0)
  (MOV R5, R1)
  (MOV R6, R2)

  (comment "get function address")
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R7, R0)

  (comment "get vector with closure parameters")
  (MOV R0, R4)
  (MOV R1, #1)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R8, R0)

  (comment "get count of closure parameters")
  (BL vector_length)
  (LSR R0, #3)
  (MOV R9, R0)
  (CMP R9, #1)
  (BNE NO_CMP_CLO_PAR)
  (comment "there is one parameter, load")
  (MOV R0, R8)
  (MOV R1, #0)
  (comment "tag int")
  (LSL R1, #3)
  (ORR R1, R1, #2)
  (BL vector_ref)
  (MOV R8, R0)

  (NO_CMP_CLO_PAR:)

  (comment "next: load parameters to registers")

  (LSR R5, #3)
  (CMP R5, #1)
  (BNE NO_NOR_PAR)
  (comment "there is one normal parameter, load")
  (MOV R0, R6)

  (comment "load closure param")
  (CMP R9, #1)
  (BNE NORM_NO_CLO_PAR)
  (comment "there is one closure parameter, load")
  (MOV R1, R8)

  (NORM_NO_CLO_PAR:)
  (B LOAD_PAR_CALL)

  (NO_NOR_PAR:)

  (comment "load closure param")
  (CMP R9, #1)
  (BNE NO_NORM_NO_CLO_PAR)
  (comment "there is one closure parameter, load")
  (MOV R0, R8)

  (NO_NORM_NO_CLO_PAR:)
  (LOAD_PAR_CALL:)

  (MOV LR, PC)
  (ADD LR, LR, #8)
  (MOV PC, R7)

  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(comment "vector")

(global-fun make-vector)
(assembler (make-vector len)
  (comment "constructs a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "allocate memory, (4 + 4 * len) bytes")
  (MOV R4, R0)
  (comment "untag int")
  (LSR R0, #3)
  (ADD R0, R0, #1)
  (MOV R2, #4)
  (MOV R3, R0)
  (MUL R0, R3, R2)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL alloc_mem)
  (comment "set length")
  (STR R4, [R0])
  (comment "tag")
  (ADD R0, R0, #0b101)
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))

(global-fun vector-ref)
(assembler (vector-ref v k)
  (comment "returns element of a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "untag v")
  (AND R3, R0, #0xFFFFFFF8)
  (comment "untag int k")
  (LSR R1, #3)
  (comment "get")
  (MOV R4, #4)
  (ADD R5, R1, #1)
  (MUL R6, R4, R5)
  (ADD R3, R3, R6)
  (LDR R0, [R3])
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(global-fun vector-set!)
(assembler (vector-set! v k obj)
  (comment "sets element of a vector")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "untag v")
  (AND R3, R0, #0xFFFFFFF8)
  (comment "untag int k")
  (LSR R1, #3)
  (comment "set")
  (MOV R4, #4)
  (ADD R5, R1, #1)
  (MUL R6, R4, R5)
  (ADD R3, R3, R6)
  (STR R2, [R3])
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))


(global-fun vector-length)
(assembler (vector-length v)
  (comment "returns length of a vector")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (LDR R0, [R0])
  (BX LR))


(global-fun vector?)
(assembler (vector? v)
  (comment "checks if x is a vector")
  (comment "vector has a mask 111")
  (comment "vector has a tag 001")
  (AND R0, R0, #0b111)
  (CMP R0, #0b101)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(comment "cons")

(global-fun cons)
(assembler (cons c1 c2)
  (comment "constructs cons")
  (comment "prologue start")
  (STMFD SP!, {LR})
  (STMFD SP!, {R4, R5, R6, R7, R8, R9})
  (STMFD SP!, {SL})
  (STMFD SP!, {FP})
  (MOV FP, SP)
  (comment "prologue end")
  (comment "allocate memory, 8 bytes")
  (MOV R4, R0)
  (MOV R5, R1)
  (MOV R0, #8)
  (comment "tag int")
  (LSL R0, #3)
  (ORR R0, R0, #2)
  (BL alloc_mem)
  (MOV R6, R0)
  (comment "set car")
  (STR R4, [R6])
  (comment "set cdr")
  (ADD R6, R6, #4)
  (STR R5, [R6])
  (comment "tag")
  (ADD R0, R0, #0b001)
  (comment "return")
  (comment "epilog start")
  (MOV SP, FP)
  (LDMFD SP!, {FP})
  (LDMFD SP!, {SL})
  (LDMFD SP!, {R4, R5, R6, R7, R8, R9})
  (LDMFD SP!, {LR})
  (BX LR)
  (comment "epilog end"))

(global-fun pair?)
(assembler (pair? a)
  (comment "checks if x is a pair")
  (comment "pair has a mask 111")
  (comment "pair has a tag 001")
  (AND R0, R0, #0b111)
  (CMP R0, #0b001)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))

(global-fun car)
(assembler (car c)
  (comment "returns car of cons")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (LDR R0, [R0])
  (BX LR))

(global-fun cdr)
(assembler (cdr c)
  (comment "returns cdr of cons")
  (comment "untag")
  (AND R0, R0, #0xFFFFFFF8)
  (comment "return")
  (ADD R0, R0, #4)
  (LDR R0, [R0])
  (BX LR))

(comment "EQUALITY")

(global-fun eq?)
(assembler (eq? a b)
  (comment "equality, compares addresses")
  (comment "implemented incorrectly")
  (CMP R0, R1)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))




(comment "Atom types predicates")

(global-fun atom?)
(assembler (atom? a)
  (comment "checks if x is an atom")
  (comment "number has mask 00001")
  (comment "number has tag 00000")
  (AND R0, R0, #1)
  (CMP R0, #0)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(global-fun number?)
(assembler (number? x)
  (comment "checks if x is a number")
  (comment "number has mask 00111")
  (comment "number has tag 00010")
  (AND R0, R0, #7)
  (CMP R0, #2)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))

(global-fun boolean?)
(assembler (boolean? x)
  (comment "checks if x is boolean")
  (comment "number has mask 00111")
  (comment "number has tag 00100")
  (AND R0, R0, #7)
  (CMP R0, #4)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))


(comment "Reference types predicates")

(global-fun reference?)
(assembler (reference? a)
  (comment "checks if x is reference")
  (comment "number has mask 00001")
  (comment "number has tag 00001")
  (AND R0, R0, #1)
  (CMP R0, #1)
  (MOVEQ R0, #12)
  (MOVNE R0, #4)
  (BX LR))
